#include <iostream>
#include <string>

using namespace std;

// Определение структуры узла для связного списка
struct Node {
    string value; // Значение элемента (строка)
    Node* next;   // Указатель на следующий узел в списке
};

// Определение структуры для множества
struct Set {
    Node* head; // Указатель на голову списка (начало множества)

    // Конструктор для инициализации множества
    Set() : head(nullptr) {} // Изначально множество пустое (голова указывает на nullptr)

    // Деструктор для освобождения памяти
    ~Set() {
        Node* current = head; // Начинаем с головы списка
        while (current != nullptr) { // Пока не достигнем конца списка
            Node* next = current->next; // Сохраняем указатель на следующий узел
            delete current; // Удаляем текущий узел, освобождая память
            current = next; // Переходим к следующему узлу
        }
    }

    // Метод для добавления элемента в множество
    void add(const string& value) {
        // Проверяем, существует ли уже элемент в множестве
        if (!contains(value)) { // Если элемент не найден
            Node* newNode = new Node{value, nullptr}; // Создаем новый узел с заданным значением и указателем на nullptr
            if (head == nullptr) { // Если список пуст
                head = newNode; // Новый узел становится головой списка
            } else {
                Node* current = head; // Иначе, начинаем с головы списка
                while (current->next != nullptr) { // Находим последний узел
                    current = current->next; // Переходим к следующему узлу
                }
                current->next = newNode; // Добавляем новый узел в конец списка
            }
        }
    }

    // Метод для проверки наличия элемента в множестве
    bool contains(const string& value) const { // Метод не изменяет состояние объекта, поэтому добавлено const
        Node* current = head; // Начинаем с головы списка
        while (current != nullptr) { // Пока не достигнем конца списка
            if (current->value == value) { // Если элемент найден
                return true; // Возвращаем true
            }
            current = current->next; // Переходим к следующему узлу
        }
        return false; // Если элемент не найден, возвращаем false
    }

    // Метод для вывода множества
    void print() const { // Метод не изменяет состояние объекта, поэтому добавлено const
        Node* current = head; // Начинаем с головы списка
        while (current != nullptr) { // Пока не достигнем конца списка
            cout << current->value << " "; // Выводим значение текущего узла
            current = current->next; // Переходим к следующему узлу
        }
        cout << endl; // Печатаем перевод строки после вывода всех элементов
    }

    // Метод для объединения множеств
    Set unionWith(const Set& other) const { // Метод не изменяет состояние объекта, добавлено const
        Set result = *this; // Копируем текущее множество в результат
        Node* current = other.head; // Начинаем с головы другого множества
        while (current != nullptr) { // Пока не достигнем конца другого множества
            result.add(current->value); // Добавляем элементы из второго множества в результат
            current = current->next; // Переходим к следующему узлу
        }
        return result; // Возвращаем объединенное множество
    }

    // Метод для пересечения множеств
    Set intersectionWith(const Set& other) const { // Метод не изменяет состояние объекта, добавлено const
        Set result; // Создаем новое множество для результата
        Node* current = head; // Начинаем с головы текущего множества
        while (current != nullptr) { // Пока не достигнем конца текущего множества
            if (other.contains(current->value)) { // Если элемент есть в другом множестве
                result.add(current->value); // Добавляем его в результат
            }
            current = current->next; // Переходим к следующему узлу
        }
        return result; // Возвращаем множество, содержащее общие элементы
    }

    // Метод для разности множеств
    Set differenceWith(const Set& other) const { // Метод не изменяет состояние объекта, добавлено const
        Set result; // Создаем новое множество для результата
        Node* current = head; // Начинаем с головы текущего множества
        while (current != nullptr) { // Пока не достигнем конца текущего множества
            if (!other.contains(current->value)) { // Если элемент отсутствует в другом множестве
                result.add(current->value); // Добавляем его в результат
            }
            current = current->next; // Переходим к следующему узлу
        }
        return result; // Возвращаем множество, содержащее элементы, отсутствующие в другом множестве
    }
};

// Функция для ввода множества
void inputSet(Set& set, const string& setName) {
    int n; // Переменная для хранения количества элементов
    cout << "Введите количество элементов в " << setName << ": "; 
    cin >> n; // Считываем количество элементов
    cout << "Введите элементы " << setName << ":" << endl; 
    for (int i = 0; i < n; ++i) { // Цикл для ввода каждого элемента
        string value; // Переменная для хранения значения элемента
        cin >> value; // Считываем значение элемента
        set.add(value); // Добавляем элемент в множество
    }
}

int main() {
    system("chcp 65001"); 
    Set set1; 
    Set set2; 

    // Ввод элементов в первое множество
    inputSet(set1, "первом множестве");

    // Ввод элементов во второе множество
    inputSet(set2, "втором множестве");

    cout << "Первое множество: "; 
    set1.print(); // Печатаем элементы первого множества

    cout << "Второе множество: "; 
    set2.print(); // Печатаем элементы второго множества

    // Объединение множеств
    Set unionSet = set1.unionWith(set2); // Получаем объединение множеств
    cout << "Объединение множеств: "; 
    unionSet.print(); // Печатаем элементы объединенного множества

    // Пересечение множеств
    Set intersectionSet = set1.intersectionWith(set2); // Получаем пересечение множеств
    cout << "Пересечение множеств: "; 
    intersectionSet.print(); // Печатаем элементы пересеченного множества

    // Разность множеств
    Set differenceSet = set1.differenceWith(set2); // Получаем разность множеств
    cout << "Разность множеств (set1 - set2): "; 
    differenceSet.print(); // Печатаем элементы разности множеств

    return 0; 
}
