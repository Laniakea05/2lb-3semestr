#include <iostream> 
#include <string>   
#include <cctype>   // Подключение библиотеки для работы с символами (например, isalnum)

using namespace std; // Использование стандартного пространства имен для упрощения кода

// узел стека
struct NodeS {
    string st; // Строка для хранения операнда или оператора
    NodeS* next; // Указатель на следующий узел в стеке
};

// Определение структуры для стека
struct Stak {
    NodeS* head = nullptr; // Указатель на верхний элемент стека (начально пустой)

    // Функция для добавления элемента в стек
    void push(const string& value) {
        // Создаем новый узел с переданным значением и указываем на текущий верхний элемент
        NodeS* newNode = new NodeS{value, head};
        head = newNode; // Обновляем верхний элемент стека
    }

    // Функция для извлечения элемента из стека
    string pop() {
        // Проверяем, не пуст ли стек
        if (head == nullptr) {
            throw runtime_error("Стек пуст"); // Генерируем исключение, если стек пуст
        }
        NodeS* temp = head; // Сохраняем текущий верхний элемент
        string value = head->st; // Сохраняем значение верхнего элемента
        head = head->next; // Обновляем верхний элемент стека
        delete temp; // Удаляем старый верхний элемент
        return value; // Возвращаем значение верхнего элемента
    }

    // Функция для проверки, пуст ли стек
    bool isEmpty() {
        return head == nullptr; // Возвращаем true, если стек пуст
    }

    // Функция для просмотра верхнего элемента стека
    string top() {
        // Проверяем, не пуст ли стек
        if (head == nullptr) {
            throw runtime_error("Стек пуст"); // Генерируем исключение, если стек пуст
        }
        return head->st; // Возвращаем значение верхнего элемента
    }
};

// Функция для определения приоритета операторов
int precedence(char op) {
    // Определяем приоритет для операторов
    if (op == '+' || op == '-') return 1; // Сложение и вычитание имеют приоритет 1
    if (op == '*' || op == '/') return 2; // Умножение и деление имеют приоритет 2
    return 0; // Если оператор не известен, возвращаем 0
}

// Функция для преобразования инфиксной записи в постфиксную
string infixToPostfix(const string& infix) {
    Stak operators; // Стек для операторов
    string postfix; // Результирующая постфиксная запись

    // Проходим по каждому символу входного инфиксного выражения
    for (char token : infix) {
        // Если токен - операнд (буква или цифра), добавляем его в постфиксную запись
        if (isalnum(token)) {
            postfix += token;
        }
        // Если токен - открывающая скобка, помещаем её в стек
        else if (token == '(') {
            operators.push(string(1, token));
        }
        // Если токен - закрывающая скобка
        else if (token == ')') {
            // Извлекаем операторы из стека до тех пор, пока не встретим открывающую скобку
            while (!operators.isEmpty() && operators.top() != "(") {
                postfix += operators.pop(); // Добавляем оператор в постфиксную запись
            }
            operators.pop(); // Удаляем открывающую скобку из стека
        }
        // Если токен - оператор
        else {
            // Извлекаем операторы из стека, пока верхний оператор имеет более высокий или равный приоритет
            while (!operators.isEmpty() && precedence(operators.top()[0]) >= precedence(token)) {
                postfix += operators.pop(); // Добавляем оператор в постфиксную запись
            }
            operators.push(string(1, token)); // Помещаем текущий оператор в стек
        }
    }

    // Выгружаем оставшиеся операторы из стека в постфиксную запись
    while (!operators.isEmpty()) {
        postfix += operators.pop();
    }

    return postfix; // Возвращаем полученную постфиксную запись
}

int main() {
    system("chcp 65001"); 
    string infix; 
    cout << "Введите инфиксное выражение: "; 
    getline(cin, infix); 

    string postfix = infixToPostfix(infix); 
    cout << "Постфиксная запись: " << postfix << endl; 
    return 0; 
}
