#include <iostream> // Подключаем библиотеку для ввода-вывода
#include <string>   // Подключаем библиотеку для работы со строками

using namespace std; // Используем стандартное пространство имен

// Структура для хранения массива строк
struct Array {
    string* data; // Указатель на массив строк
    int size;     // Размер массива

    // Конструктор для инициализации массива
    Array(int s) : size(s) {
        data = new string[size]; // Выделяем память под массив строк размером size
    }

    // Деструктор для освобождения памяти
    ~Array() {
        delete[] data; // Освобождаем память, выделенную под массив строк
    }
};

// Функция для сравнения строки с шаблоном
bool matches(const string& str, const string& pattern) {
    int sLen = str.length(); // Длина строки
    int pLen = pattern.length(); // Длина шаблона
    
    // Создаем двумерный массив для хранения результатов сопоставления
    bool** dp = new bool*[sLen + 1]; // Размер массива по строкам (sLen + 1)
    for (int i = 0; i <= sLen; ++i) {
        dp[i] = new bool[pLen + 1]; // Размер массива по столбцам (pLen + 1)
    }

    // Инициализация
    dp[0][0] = true; // Пустая строка соответствует пустому шаблону

    // Обработка шаблона, начинающегося с '*'
    for (int j = 1; j <= pLen; ++j) {
        if (pattern[j - 1] == '*') {
            dp[0][j] = dp[0][j - 1]; // '*' может соответствовать пустой строке
        }
    }

    // Заполнение таблицы сопоставления
    for (int i = 1; i <= sLen; ++i) {
        for (int j = 1; j <= pLen; ++j) {
            // Проверяем, совпадает ли текущий символ строки с символом шаблона
            if (pattern[j - 1] == str[i - 1] || pattern[j - 1] == '?') {
                dp[i][j] = dp[i - 1][j - 1]; // Совпадение символов
            } 
            // Если текущий символ шаблона - '*', проверяем два случая:
            else if (pattern[j - 1] == '*') {
                dp[i][j] = dp[i - 1][j] || dp[i][j - 1]; // '*' может соответствовать одному или более символам
            } else {
                dp[i][j] = false; // Нет совпадения
            }
        }
    }

    bool result = dp[sLen][pLen]; // Получаем результат сопоставления (соответствует ли вся строка шаблону)
    
    // Освобождение памяти, выделенной под двумерный массив
    for (int i = 0; i <= sLen; ++i) {
        delete[] dp[i]; // Освобождаем каждую строку
    }
    delete[] dp; // Освобождаем основной массив указателей

    return result; // Возвращаем результат сопоставления (true или false)
}

int main() {
    string input; // Переменная для хранения строки на проверку
    string pattern; // Переменная для хранения шаблона

    // Запрашиваем у пользователя строку для проверки
    cout << "Введите строку для проверки: ";
    getline(cin, input); // Считываем строку с пробелами

    // Запрашиваем у пользователя шаблон
    cout << "Введите шаблон (используйте '*' для любой последовательности и '?' для одного символа): ";
    getline(cin, pattern); // Считываем шаблон с пробелами

    // Проверяем соответствие введенной строки с шаблоном
    if (matches(input, pattern)) {
        // Если строка соответствует шаблону, выводим соответствующее сообщение
        cout << "\"" << input << "\" соответствует шаблону \"" << pattern << "\"" << endl;
    } else {
        // Если строка не соответствует шаблону, выводим соответствующее сообщение
        cout << "\"" << input << "\" не соответствует шаблону \"" << pattern << "\"" << endl;
    }

    return 0; // Завершение программы
}
