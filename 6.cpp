#include <iostream> // Подключаем библиотеку для ввода/вывода
#include <string>   // Подключаем библиотеку для работы со строками
#include <vector>   // Подключаем библиотеку для работы с векторами (не используется в данном коде, но может быть полезной)

using namespace std; // Используем пространство имен std для удобства (чтобы не писать std:: перед каждым элементом из библиотеки)


// Определение структуры узла для хеш-таблицы
struct Node {
    char key;           // Символ, который мы будем хранить в узле
    Node* next;        // Указатель на следующий узел (используется для реализации связного списка)

    // Конструктор структуры для инициализации узла с символом
    Node(char k) : key(k), next(nullptr) {} // Инициализируем ключ и устанавливаем указатель на следующий узел в nullptr
};

// Определение класса хеш-таблицы
class Hash {
public:
    static const int size = 256;   // Определяем размер хеш-таблицы (256, чтобы вместить все символы ASCII)
    Node* table[size];             // Массив указателей на узлы (представляет хеш-таблицу)

    // Конструктор хеш-таблицы
    Hash() {
        for (int i = 0; i < size; i++) {
            table[i] = nullptr;     // Инициализируем все элементы таблицы значением nullptr
        }
    }

    // Хеш-функция, которая принимает символ и возвращает индекс
    int hash(char key) {
        return key; // Используем значение символа как индекс (это позволит эффективно использовать хеш-таблицу для символов ASCII)
    }

    // Метод для вставки символа в хеш-таблицу
    bool insert(char key) {
        int index = hash(key); // Получаем индекс для данного символа

        // Проверка на наличие символа в таблице
        Node* current = table[index]; // Доступ к списку узлов по индексу
        while (current != nullptr) { // Проходим по всему списку для этого индекса
            if (current->key == key) {
                return false; // Если символ уже существует в списке, возвращаем false
            }
            current = current->next; // Переходим к следующему узлу в списке
        }

        // Если символ не найден, добавляем новый узел
        Node* newNode = new Node(key); // Создаем новый узел с данным символом
        newNode->next = table[index]; // Указываем, что следующий узел нового узла - текущая голова списка
        table[index] = newNode; // Устанавливаем новую голову списка на новый узел
        return true; // Возвращаем true, так как символ успешно добавлен
    }

    // Метод для очистки хеш-таблицы и освобождения памяти
    void clear() {
        for (int i = 0; i < size; i++) { // Проходим по всем индексам в таблице
            Node* current = table[i]; // Доступ к списку узлов по текущему индексу
            while (current != nullptr) { // Пока есть узлы в списке
                Node* temp = current; // Сохраняем текущий узел во временную переменную
                current = current->next; // Переходим к следующему узлу
                delete temp; // Освобождаем память, занятую текущим узлом
            }
            table[i] = nullptr; // Устанавливаем указатель на пустоту для текущего индекса
        }
    }

    // Деструктор для автоматической очистки хеш-таблицы при уничтожении объекта
    ~Hash() {
        clear(); // При уничтожении объекта очищаем хеш-таблицу
    }
};

int main() {
    string s; // Объявляем строку для хранения пользовательского ввода
    cout << "Введите строку: ";
    getline(cin, s); // Читаем строку, включая пробелы

    Hash hashTable; // Создаем экземпляр хеш-таблицы для хранения уникальных символов
    string uniqueString; // Строка для хранения уникальных символов

    // Обработка каждого символа в введенной строке
    for (char c : s) { // Проходим по каждому символу в строке
        if (hashTable.insert(c)) { // Если символ успешно добавлен в хеш-таблицу (это новый, уникальный символ)
            uniqueString += c; // Добавляем символ в результирующую строку
        }
    }

    // Подсчет уникальных символов
    int uniqueCount = uniqueString.size(); // Получаем количество уникальных символов

    // Вывод информации о количестве уникальных символов и самих символах
    cout << uniqueCount << " " << uniqueString << endl;

    return 0; 
}
